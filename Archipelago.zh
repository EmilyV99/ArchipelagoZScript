#include "json.zh"
namespace Archipelago
{
    using namespace JSON;
    CONFIGB AP_LOG = true;
    CONFIG AP_LOG_COMMUNICATION = 1; // 0 = none, 1 = some, 2 = full
    CONFIGB AP_DEV_LOG = true;

    enum ClientStatus
    {
        CLIENT_UNKNOWN = 0,
        CLIENT_CONNECTED = 5,
        CLIENT_READY = 10,
        CLIENT_PLAYING = 20,
        CLIENT_GOAL = 30
    };

    enum SocketStatus
    {
        STATUS_DISCONNECTED,
        STATUS_CONNECTING,
        STATUS_CONNECTED,
        STATUS_AUTHENTICATED
    };

    DEFINEL ITEM_PROGRESSIVE = 001Lb;
    DEFINEL ITEM_USEFUL      = 010Lb;
    DEFINEL ITEM_TRAP        = 100Lb;
    class NetworkItem
    {
        int item_id;
        int location_id;
        int player_id;
        long flags;
        bool valid;
        NetworkItem(int iid, int lid, int pid, long fl)
        {
            item_id = iid;
            location_id = lid;
            player_id = pid;
            flags = fl;
            valid = true;
        }
        NetworkItem(JSONRef ref)
        {
            valid = true;

            JSONRef js = new JSONRef(ref);
            if(js->sub_find({NULL,{"item"}}))
                item_id = js->get_int();
            else valid = false;

            js->from(ref);
            if(js->sub_find({NULL,{"location"}}))
                location_id = js->get_int();
            else valid = false;

            js->from(ref);
            if(js->sub_find({NULL,{"player"}}))
                player_id = js->get_int();
            else valid = false;

            js->from(ref);
            if(js->sub_find({NULL,{"flags"}}))
                flags = js->get_long();
            else valid = false;

            delete js;
        }
    }
    
    class NetworkPlayer
    {
        int team;
        int slot_id;
        char32 alias[1];
        char32 name[1];
        bool valid;
        NetworkPlayer(int teamid, int slotid, char32 alias_str, char32 name_str)
        {
            team = teamid;
            slot_id = slotid;
            sprintf(alias, "%s", alias_str);
            sprintf(name, "%s", name_str);
            valid = true;
        }
        NetworkPlayer(JSONRef ref)
        {
            valid = true;

            JSONRef js = new JSONRef(ref);
            if(js->sub_find({NULL,{"team"}}))
                team = js->get_int();
            else valid = false;

            js->from(ref);
            if(js->sub_find({NULL,{"slot"}}))
                slot_id = js->get_int();
            else valid = false;

            js->from(ref);
            if(js->sub_find({NULL,{"alias"}}))
                js->get_trim(alias);
            else valid = false;

            js->from(ref);
            if(js->sub_find({NULL,{"name"}}))
                js->get_trim(name);
            else valid = false;

            delete js;
        }
    }

    namespace Settings
    {
        DEFINEL ITEMS_NONE                  = 000Lb;
        DEFINEL ITEMS_REMOTE                = 001Lb;
        DEFINEL ITEMS_REMOTE_STARTING       = 101Lb;
        DEFINEL ITEMS_REMOTE_LOCAL          = 011Lb;
        DEFINEL ITEMS_REMOTE_STARTING_LOCAL = 111Lb;

        void ap_get_game(char32 buf); //Return your game name
        long items_handling() : default 101Lb; //return your item handling mode
        void add_tags(JSONRef ref);
        void on_room_info(JSONRef ref);
        void on_connected(JSONRef ref);
        void on_item_received(NetworkItem itemlist);
        void on_location_scouts(NetworkItem itemlist);
        void on_room_update(JSONRef ref);
        bool on_print_json(JSONRef ref) : default true;
        void on_bounced(JSONRef ref);
        void on_retrieved(JSONRef ref);
        void on_set_reply(JSONRef ref);
        void do_remove_location(int id);
    }
    namespace DeathLink
    {
        char32 death_reason[1];
        //Sends deathlink deaths when you die.
        hero script AP_DeathLink_OnDeath
        {
            int cur_amnesty = 0;
            void run()
            {
                if(cur_amnesty < deathlink_amnesty)
                    ++cur_amnesty;
                else
                {
                    cur_amnesty = 0;
                    unless(death_reason[0])
                        sprintf(death_reason,"%s died",slot);
                    death_send(death_reason);
                    death_reason[0] = 0;
                }
            }
        }
        //Optional script; sets the 'death reason' for DeathLink
        generic script AP_DeathLink_OnDamage
        {
            void run()
            {
                loop(q : 0=..GENSCR_NUMEVENT)
                    this->EventListen[q] = q==GENSCR_EVENT_HERO_HIT_2;
                loop()
                {
                    WaitEvent();
                    char32 enemybuf[0];
                    switch(Game->EventData[GENEV_HEROHIT_HITTYPE])
                    {
                        case OBJTYPE_NPC:
                            npc obj = Game->EventData[GENEV_HEROHIT_HITOBJ];
                            npcdata nd = Game->LoadNPCData(obj->ID);
                            nd->GetName(enemybuf);
                            sprintf(death_reason, "%s was killed by '%s'", slot, enemybuf);
                            break;
                        case OBJTYPE_LWPN:
                            lweapon obj = Game->EventData[GENEV_HEROHIT_HITOBJ];
                            sprintf(death_reason, "%s was killed by their own weapon", slot);
                            break;
                        case OBJTYPE_EWPN:
                            eweapon obj = Game->EventData[GENEV_HEROHIT_HITOBJ];
                            sprintf(death_reason, "%s was killed by an enemy weapon", slot);
                            break;
                        case OBJTYPE_COMBODATA:
                            combodata obj = Game->EventData[GENEV_HEROHIT_HITOBJ];
                            sprintf(death_reason, "%s was killed by the environment", slot);
                            break;
                        default:
                            sprintf(death_reason,"%s died", slot);
                            break;
                    }
                }
            }
        }

        void death_send(char32 reason)
        {
            unless(do_deathlink)
                return;
            char32 msg[0];
            long seconds = (GetSystemTime(RTC_SECOND)*1L)
                + (GetSystemTime(RTC_MINUTE)*60L)
                + (GetSystemTime(RTC_HOUR)*3600L);
            sprintf(msg, "[{\"cmd\":\"Bounce\",\"tags\":[\"DeathLink\"],\"data\":{\"time\":%l,\"source\":\"%s\",\"cause\":\"%s\"}}]",
                seconds, death_alias, reason);
            sock->Send(msg);
        }

        void death_recv(char32 source, char32 cause)
        {
            if(cause[0])
                printf("[DEATHLINK] Perished due to: %s\n", cause);
            else printf("[DEATHLINK] Perished due to: %s died\n", source);
            Hero->Kill(true);
        }
    }

    char32 ip[1];
    char32 port[1];
    char32 slot[1];
    char32 pwd[1];
    char32 death_alias[1];
    long ap_uid;

    bool did_setup = false;

    websocket sock;
    SocketStatus status;

    bool do_deathlink = false;
    int deathlink_amnesty = 0;
    int player_id, player_team;
    bool collected_locations[0];
    bool collected_items[0];

    int quitkey = KEY_Q;
    char32 quitchar()
    {
        return KeyToChar(quitkey,false,true);
    }

    bool checked_location(int id)
    {
        return id < SizeOfArray(collected_locations) && collected_locations[id];
    }

    bool collected_item(int id)
    {
        return id < SizeOfArray(collected_items) && collected_items[id];
    }

    void mark_location_checked(int id)
    {
        if(id >= SizeOfArray(collected_locations))
            ResizeArray(collected_locations, id+1);
        collected_locations[id] = true;
    }
    void mark_item_collected(int id)
    {
        if(id >= SizeOfArray(collected_items))
            ResizeArray(collected_items, id+1);
        collected_items[id] = true;
    }

    void connect_socket()
    {
        clear_requests();
        bool ssl = true;
        char32 buf[0];
        if(pwd[0])
            printf("[CONNECT] %s:%s (as %s, pwd '%s')\n", ip, port, slot, pwd);
        else printf("[CONNECT] %s:%s (as %s)\n", ip, port, slot);
        status = STATUS_CONNECTING;
        int attempt_count;
        int delay = 0;
        char32 quit_char = quitchar();
        while(true)
        {
            if(sock)
            {
                sock->Free();
                sock = NULL;
            }
            if(Input->Key[quitkey])
            {
                printf("%c pressed; cancelling connection\n", quit_char);
                return; //Failed, and user cancelled
            }
            if(delay)
            {
                --delay;
                Waitframe();
                continue;
            }
            unless(++attempt_count % 10)
            {
                printf("Failing a lot... waiting a bit to try again (Attempts: %d, press %c to quit)\n", attempt_count, quit_char);
                delay = 15*60;
                continue;
            }
            sprintf(buf, "%s://%s:%s", ssl ? "wss" : "ws", ip, port);
            sock = Game->LoadWebSocket(buf);
            while(sock->State == WEBSOCKET_STATE_CONNECTING)
            {
                if(Input->Key[quitkey])
                    continue 2;
                Waitframe();
            }
            if(sock->State == WEBSOCKET_STATE_CLOSED)
            {
                char32 error[0];
                sock->GetError(error);
                switch(error)
                {
                    case "endpoint not secure":
                        break;
                    default:
                        printf("Failed to connect (%s): '%s'\n", ssl ? "wss" : "ws", error);
                }
                ssl = !ssl;
                continue;
            }
            if(sock->State != WEBSOCKET_STATE_OPEN)
            {
                printf("Failed to connect (%s): '%d'\n", ssl ? "wss" : "ws", sock->State);
                ssl = !ssl;
                continue;
            }
            if(!sock)
            {
                printf("Fucked up error! (%s)\n", ssl ? "wss" : "ws");
                ssl = !ssl;
                continue;
            }
            break;
        }
    }

    void disconnect_socket()
    {
        if(sock)
            sock->Free();
        sock = NULL;
        ResizeArray(collected_locations, 0);
        ResizeArray(collected_items, 0);
        status = STATUS_DISCONNECTED;
    }
    
    bool retry()
    {
        if(sock)
        {
            _do_connect();
            return true;
        }
        return false;
    }

    void clear_requests()
    {
        //!TODO
    }

    bool update_socket()
    {
        if(!sock || sock->State == WEBSOCKET_STATE_CLOSED)
        {
            if(AP_LOG)
                printf("Disconnected from Archipelago");
            return retry();
        }
        return true;
    }

    bool socket_valid()
    {
        return sock && sock->State == WEBSOCKET_STATE_OPEN;
    }

    generic script APConnect
    {
        void run()
        {
            connect_socket();
        }
    }

    generic script APHandler
    {
        void run(bool end_on_auth)
        {
            #option STRING_SWITCH_CASE_INSENSITIVE on
            ap_setup();
            bool do_exit = false;
            until(do_exit)
            {
                until(sock || do_exit)
                    Waitframe();
                while(sock && update_socket() && !do_exit)
                {
                    while(sock->HasMessage && !do_exit)
                    {
                        char32 msg = sock->Receive();
                        switch(sock->MessageType)
                        {
                            case WEBSOCKET_MESSAGE_TYPE_TEXT:
                            {
                                if(AP_LOG_COMMUNICATION > 1)
                                    printf("[RECV]: %s\n", msg);
                                JSONRef ref = new JSONRef(msg);
                                JSONRef ref2 = new JSONRef(msg);
                                ref->find({{-1}});

                                JSONRef resp = new JSONRef();

                                char32 buf[1];

                                int q = 0;
                                if(ref->first_indx())
                                    do
                                    {
                                        if(ref->find({{q},{"cmd"}}))
                                            ref->get_trim(buf);
                                        else continue;
                                        ref->find({{q}});

                                        char32 response[] = "[{}]";
                                        resp->strptr = response;
                                        resp->find({{0},{""}});
                                        
                                        if(AP_LOG_COMMUNICATION)
                                            printf("[COMMAND] %s\n", buf);
                                        switch(buf)
                                        {
                                            case "RoomInfo":
                                            {
                                                char32 gamebuf[1];
                                                Settings::ap_get_game(gamebuf);
                                                resp->add_key_str("cmd","Connect");
                                                resp->add_key_str("game", gamebuf);
                                                resp->add_key_str("name", slot);
                                                resp->add_key_str("password", pwd);
                                                resp->add_key_long("uuid", ap_uid);
                                                resp->add_key("tags", "[]");
                                                resp->add_key("version", "{}");
                                                resp->add_key_long("items_handling", Settings::items_handling());
                                                resp->add_key_bool("slot_data", true);
                                                resp->find({{0},{"tags"}});
                                                Settings::add_tags(resp);
                                                resp->find({{0},{"version"}});
                                                // AP 0.4.4
                                                resp->add_key_int("major",0);
                                                resp->add_key_int("minor",4);
                                                resp->add_key_int("build",4);
                                                resp->add_key_str("class","Version");
                                                
                                                status = STATUS_CONNECTED;
                                                Settings::on_room_info(ref);
                                                break;
                                            }
                                            case "Connected":
                                            {
                                                ResizeArray(collected_locations, 0);
                                                ResizeArray(collected_items, 0);

                                                ref2->from(ref);
                                                ref2->sub_find({NULL,{"slot"}});
                                                player_id = ref2->get_int();
                                                ref2->from(ref);
                                                ref2->sub_find({NULL,{"team"}});
                                                player_team = ref2->get_int();

                                                ref2->from(ref);
                                                ref2->sub_find({NULL,{"missing_locations"}});
                                                if(ref2->first_indx())
                                                    do
                                                    {
                                                        int locid = ref2->get_int();
                                                        if(locid >= SizeOfArray(collected_locations))
                                                            ResizeArray(collected_locations, locid+1);
                                                    }
                                                    while(ref2->next_indx());

                                                ref2->from(ref);
                                                ref2->sub_find({NULL,{"checked_locations"}});
                                                if(ref2->first_indx())
                                                    do
                                                    {
                                                        int locid = ref2->get_int();
                                                        if(locid >= SizeOfArray(collected_locations))
                                                            ResizeArray(collected_locations, locid+1);
                                                        collected_locations[locid] = true;
                                                    }
                                                    while(ref2->next_indx());

                                                do_deathlink = false;
                                                ref2->from(ref);
                                                if(ref2->sub_find({NULL,{"slot_data","death_link"}}))
                                                    if(ref2->get_bool())
                                                        do_deathlink = true;
                                                ref2->from(ref);
                                                if(ref2->sub_find({NULL,{"slot_data","DeathLink"}}))
                                                    if(ref2->get_bool())
                                                        do_deathlink = true;
                                                ref2->from(ref);
                                                if(ref2->sub_find({NULL,{"slot_data","deathlink_amnesty"}}))
                                                    deathlink_amnesty = ref2->get_int();
                                                else if(ref2->sub_find({NULL,{"slot_data","DeathLinkAmnesty"}}))
                                                    deathlink_amnesty = ref2->get_int();
                                                else deathlink_amnesty = 0;
                                                
                                                if(AP_LOG)
                                                    printf("Connected to Archipelago (%s:%s as %s)\n",ip,port,slot);
                                                if(AP_DEV_LOG)
                                                    printf("[DEV] player_id = %d, player_team = %d, deathlink = %s, amnesty = %d\n", player_id, player_team, do_deathlink ? "true" : "false", deathlink_amnesty);
                                                status = STATUS_AUTHENTICATED;
                                                
                                                Settings::on_connected(ref);

                                                if(do_deathlink)
                                                {
                                                    resp->add_key_str("cmd","ConnectUpdate");
                                                    resp->add_key("tags", "[]");
                                                    resp->find({{0},{"tags"}});
                                                    resp->add_indx_str("DeathLink");
                                                    Settings::add_tags(resp);

                                                    if(Game->GetHeroScript("AP_DeathLink_OnDeath") != 3)
                                                        printf("Script 'AP_DeathLink_OnDeath' needs to be assigned to the 'onDeath' slot for 'DeathLink' to work!\n");
                                                    int genscr = Game->GetGenericScript("AP_DeathLink_OnDamage");
                                                    if(genscr > 0)
                                                        RunGenericScript(genscr);
                                                }

                                                if(end_on_auth)
                                                    do_exit = true;
                                                break;
                                            }
                                            case "PrintJSON":
                                            {
                                                if(Settings::on_print_json(ref))
                                                {
                                                    if(ref->find({{q},{"data"}}))
                                                    {
                                                        char32 buf[1];
                                                        char32 buf2[1];
                                                        if(ref->first_indx())
                                                            do
                                                            {
                                                                ref2->from(ref);
                                                                if(ref2->sub_find({NULL,{"text"}}))
                                                                {
                                                                    if(buf[0])
                                                                    {
                                                                        ref2->get_trim(buf2);
                                                                        sprintf(buf, "%s %s", buf, buf2);
                                                                    }
                                                                    else ref2->get_trim(buf);
                                                                }
                                                            } while(ref->next_indx());
                                                        if(SizeOfArray(buf) > 30 && buf[-7] == '/'
                                                            && buf[-6] == 'h' && buf[-5] == 'e'
                                                            && buf[-4] == 'l' && buf[-3] == 'p')
                                                        {
                                                            if(AP_LOG_COMMUNICATION)
                                                                printf("[BLOCKED] Useless help message\n");
                                                            break; //skip help message, doesn't apply
                                                        }
                                                        printf("[AP] %s\n", buf);
                                                    }
                                                }
                                                break;
                                            }
                                            case "ConnectionRefused":
                                            {
                                                if(ref->sub_find({NULL,{"errors"}}))
                                                {
                                                    if(ref->first_indx())
                                                    {
                                                        char32 buf[0];
                                                        ref->get_trim(buf);
                                                        switch(buf)
                                                        {
                                                            case "InvalidSlot":
                                                                printf("[AP] Connection Error: The slot '%s' was not found!\n", slot);
                                                                break;
                                                            case "InvalidPassword":
                                                                printf("[AP] Connection Error: The password was incorrect!\n");
                                                                break;
                                                            //case "InvalidGame":
                                                            //case "IncompatibleVersion":
                                                            //case "InvalidItemsHandling":
                                                            default:
                                                                printf("[AP] Connection Error: %s\n", buf);
                                                                break;
                                                        }
                                                    }
                                                }
                                                disconnect_socket();
                                                if(end_on_auth)
                                                    do_exit = true;
                                                break;
                                            }
                                            case "ReceivedItems":
                                            {
                                                if(ref->sub_find({NULL,"items"}))
                                                {
                                                    NetworkItem items[0];
                                                    if(ref->first_indx())
                                                    {
                                                        do
                                                        {
                                                            NetworkItem itm = new NetworkItem(ref);
                                                            if(itm->valid)
                                                            {
                                                                mark_item_collected(itm->item_id);
                                                                if(itm->player_id == player_id)
                                                                {
                                                                    mark_location_checked(itm->location_id);
                                                                    Settings::do_remove_location(itm->location_id);
                                                                }
                                                                ArrayPushBack(items, itm);
                                                            }
                                                            else delete itm;
                                                        } while(ref->next_indx());
                                                        Settings::on_item_received(items);
                                                        for(item : items)
                                                            delete item;
                                                    }
                                                }
                                                break;
                                            }
                                            case "LocationInfo":
                                            {
                                                if(ref->sub_find({NULL,"locations"}))
                                                {
                                                    NetworkItem items[0];
                                                    if(ref->first_indx())
                                                    {
                                                        do
                                                        {
                                                            NetworkItem itm = new NetworkItem(ref);
                                                            if(itm->valid)
                                                                ArrayPushBack(items, itm);
                                                            else delete itm;
                                                        } while(ref->next_indx());
                                                        Settings::on_location_scouts(items);
                                                        for(item : items)
                                                            delete item;
                                                    }
                                                }
                                                break;
                                            }
                                            case "RoomUpdate":
                                            {
                                                Settings::on_room_update(ref);
                                                if(ref->find({{q},{"checked_locations"}}))
                                                    if(ref->first_indx())
                                                        do
                                                        {
                                                            int id = ref->get_int();
                                                            mark_location_checked(id);
                                                            Settings::do_remove_location(id);
                                                        } while(ref->next_indx());
                                                break;
                                            }
                                            case "Bounced":
                                            {
                                                Settings::on_bounced(ref);
                                                if(ref->find({{q},{"tags"}}))
                                                {
                                                    if(ref->first_indx())
                                                        do
                                                        {
                                                            char32 buf[1];
                                                            ref->get_trim(buf);
                                                            unless(strcmp(buf,"DeathLink"))
                                                            {
                                                                char32 sbuf[1];
                                                                char32 cbuf[1];
                                                                if(ref->find({{q},{"data","source"}}))
                                                                    ref->get_trim(sbuf);
                                                                if(ref->find({{q},{"data","cause"}}))
                                                                    ref->get_trim(cbuf);
                                                                DeathLink::death_recv(sbuf,cbuf);
                                                                break;
                                                            }
                                                        } while(ref->next_indx());
                                                }
                                                break;
                                            }
                                            case "Retrieved":
                                            {
                                                Settings::on_retrieved(ref);
                                                break;
                                            }
                                            case "SetReply":
                                            {
                                                Settings::on_set_reply(ref);
                                                break;
                                            }
                                            case "InvalidPacket":
                                                printf("[ERR]: %s\n", msg);
                                                break;
                                            case "DataPackage":
                                                printf("[DATAPACK]: %s\n", msg);
                                                //!TODO Do something with these?? idk
                                                break;
                                            default:
                                                printf("[???]: %s\n", msg);
                                                break;
                                        }
                                        if(strlen(response) > 4)
                                        {
                                            if(AP_LOG_COMMUNICATION > 1)
                                                printf("[SEND] %s\n", response);
                                            sock->Send(response);
                                        }
                                    } while(++q && ref->next_indx());

                                delete ref;
                                delete ref2;
                                delete resp;
                                break;
                            }
                            default:
                                printf("[RECV UNKNOWN]: '%ad'\n", msg);
                                break;
                        }
                    }
                    Waitframe();
                }
            }
        }
    }

    void _do_connect()
    {
        if(int scr = CheckGenericScript("APConnect"))
            RunGenericScriptFrz(scr);
        else connect_socket();
    }

    void ap_setup()
    {
        unless(did_setup)
            ap_uid = RandGen->LRand();
        did_setup = true;
    }

    bool ap_connect(char32 _ip, char32 _port, char32 _slot, char32 _pwd, char32 _death_alias = NULL)
    {
        disconnect_socket();
        sprintf(ip,"%s",_ip[0] ? _ip : "archipelago.gg");
        sprintf(port,"%s",_port[0] ? _port : "38281");
        sprintf(slot,"%s",_slot);
        sprintf(pwd,"%s",_pwd);
        sprintf(death_alias,"%s",_death_alias ? _death_alias : slot);
        _do_connect();
        unless(sock)
            return false;
        if(int scr = CheckGenericScript("APHandler"))
            RunGenericScript(scr, {false});
        return true;
    }

    void send_sync()
    {
        unless(socket_valid()) return;
        sock->Send("[{\"cmd\":\"Sync\"}]");
    }

    void send_location_checks(...int[] locations)
    {
        unless(socket_valid()) return;
        char32 msg[] = "[{\"cmd\":\"LocationChecks\",\"locations\":[]}]";
        JSONRef ref = new JSONRef(msg);
        ref->find({{0},{"locations"}});
        for(loc : locations)
            ref->add_indx_int(loc);
        sock->Send(msg);
        delete ref;
    }

    void send_location_scouts(int hint_mode, ...int[] locations)
    {
        unless(socket_valid()) return;
        char32 msg[0];
        sprintf(msg, "[{\"cmd\":\"LocationScouts\",\"locations\":[],\"create_as_hint\":%d}]",hint_mode);
        JSONRef ref = new JSONRef(msg);
        ref->find({{0},{"locations"}});
        for(loc : locations)
            ref->add_indx_int(loc);
        sock->Send(msg);
        delete ref;
    }

    void send_status_update(ClientStatus status)
    {
        unless(socket_valid()) return;
        char32 msg[0];
        sprintf(msg, "[{\"cmd\":\"StatusUpdate\",\"status\":%d}]",status);
        sock->Send(msg);
    }

    void send_say(char32 msg)
    {
        unless(socket_valid()) return;
        char32 msg[0];
        sprintf(msg, "[{\"cmd\":\"Say\",\"text\":%s}]",msg);
        sock->Send(msg);
    }
}
